#!/usr/bin/python

# -*- coding: utf-8 -*-
"""
Created on Tue Sep 11 08:50:13 2012
An attempt to build a PARAlyser-like tool using existing python libraries.
Dependenies:
    - numpy/pandas
    - scipy/statmodels
    - matplotlib/chako(?)
    
Uses statsmodels or scipy for kernel density estimation.

Takes samtools-produced .pileup file as input.

@author: ilya shamovsky 
"""

from __future__ import division
import argparse, re
import numpy as np
#import pandas as pd
#import matplotlib.pyplot as plt
import pylab
from ggstyle import rstyle
from scipy.stats.kde import gaussian_kde
# TODO: Implement through statsmodels
#import statsmodels.api as sm

# TODO: In the order of importance/urgency:
#   - port all this crap to numpy. 
#   - allow kde parameters to be specified
#   - allow different substitutions for different photoactivatable x-linkers

parser = argparse.ArgumentParser() 
parser.add_argument('pileup_file', type=str, 
                        help='.pileup file generated by samtools')
parser.add_argument('-r', '--min_reads', type=int, default=3,
                        help='minimum read depth in a group, default 3')
parser.add_argument('-c', '--conv', type=int, default=1,
                        help='minimum number of T -> C conversions in a group')
parser.add_argument('-s', '--conv_sites', type=int, default=2,
                        help='minimum number of conversion sites in a group')
parser.add_argument('-M', '--mask', type=str, default='', nargs='*',
                        help='regions to mask in a form <chr>:<min>-<max>')
parser.add_argument('-v', '--verbosity', action='count',
                        help='increase output verbosity')
# PILEUP_FILE = '/home/ilya/reads/b2/parclip/E1_1.pileup'

args = parser.parse_args()

# Build a list of masked regions. A bit convoluted.
r = re.compile(r'(?P<chr>\w+):(?P<start>\d+)-(?P<end>\d+)')
masked = [(m.group('chr'), int(m.group('start')), int(m.group('end')),) for m in 
    (r.search(s) for s in args.mask)]

    
def is_masked(chro, coord):
    '''
    Returns True if the position specified by `chro` and `coord` is within
    a masked region. Only check chromosome for now.
    '''
    # FIXME: Need to add cordinates check here but this is silly and
    # inefficient. Needs a fix.
    if chro in [a[0] for a in masked]:
        return True
    else:
        return False
    

def get_reads_for_chromosome(chromo, sites):
    return [tuple([chro, ncoord, num_reads, strand, nconv,]) for
    chro, ncoord, num_reads, strand, nconv in sites if chro == chromo]    


def get_num_conv(read):
    return read.count('c') + read.count('C')


def get_signal(group):
    '''
    Returns signal value (list of tuples (position, value)) for a given read group calculated as:
        SUM(Xi(T->C)/N(T->C))
    '''
    return sum([[read[1]]*get_num_conv(read[4]) for read in group if read[2] == 'T'], [])
    
def get_background(group):
    '''
    Returns background (list of (position, value) tuples) for a given read group
    calculated as:
        SUM(Xi(T->T)/N(T->T))
    '''
    return sum([[read[1]]*(read[3] - get_num_conv(read[4])) for read in group if read[2] == 'T'], [])


def get_seq_space(group):
    '''
    Returns nucleotide coordinates for the given read group.
    '''
    coords = [read[1] for read in group]
    nt_min = min(coords)
    nt_max = max(coords)
    return np.linspace(nt_min, nt_max, nt_max-nt_min)

# TODO: The following code needs to be refactored as a function that returns
# read groups. Then another function will return a set of read group
# chromosomal loci to enable comparison between different samples.
    
current_group = []
read_groups = []
nconv_sites = 0
if args.verbosity > 0:
    print 'Generating read groups ...'

with open(args.pileup_file) as f:
    for line in f:
        chro, coord, ref_seq, reads, matches, score = line.split('\t')
        num_reads = int(reads)
        ncoord = int(coord)
        if not is_masked(chro, ncoord):
            if num_reads > args.min_reads:
                current_group.append(tuple([chro, ncoord, ref_seq, num_reads, matches, score,]))
                if ref_seq == 'T' and (matches.count('C') > 0 or matches.count('c') > 0):
                    nconv_sites += 1
            else:
                # Save the read group if we have enough conversion sites
                if nconv_sites > args.conv_sites:
                    read_groups.append(current_group)
                    print '>Found group at %s:%d\t%d nt long' % (chro, ncoord, len(current_group))
                    print ''.join([x[2] for x in current_group])
                nconv_sites = 0
                current_group = []            

if args.verbosity > 1:
    print 'Generated %d read groups.' % len(read_groups)            

# TODO: Set this as args
import matplotlib
matplotlib.rcParams['savefig.dpi'] = 300

for group in read_groups:
    signal = get_signal(group)
    background = get_background(group)
    xs = get_seq_space(group)
    
    kde_signal = gaussian_kde(signal)
    #kde_signal.covariance_factor = lambda : .25
    #kde_signal._compute_covariance()
    kde_background = gaussian_kde(background)
    #kde_background.covariance_factor = lambda : .25
    #kde_background._compute_covariance()
    kde_s = kde_signal(xs)
    kde_b = kde_background(xs)
    fig = pylab.plt.figure()
    fig.patch.set_alpha(0)
    
    ax = fig.add_subplot(111)
    pylab.plot(xs, kde_s, label="signal", color="#dc322f", alpha=0.8)
    pylab.plot(xs,kde_b, label="background", color="#268bd2", alpha=0.8)
    ax.legend()
    ax.set_xlabel(group[0][0])
    ax.set_ylabel('kde signal')
    ax.title.set_fontsize(18)
    ax.fill_between(xs,kde_s, color="#dc322f", alpha=0.4)
    ax.fill_between(xs,kde_b, color="#268bd2", alpha=0.4)
    rstyle(ax)
#    plt.bar(xs, kde_signal(xs), facecolor="#dc322f", edgecolor='#dc322f', alpha=0.8)
#    plt.bar(xs, kde_background(xs), facecolor="#268bd2", edgecolor='#268bd2', alpha=0.6)
    pylab.plt.show()