#!/usr/bin/python

# -*- coding: utf-8 -*-
"""
Created on Tue Sep 11 08:50:13 2012
Fast and stupid sequence coverage plotter.
Takes samtools-produced .pileup file as input, produces ggplot2-like
coverage graph complete with kernel density estimation function.

@author: ilya shamovsky 
"""

import numpy as np
import argparse
from pylab import *
from ggstyle import rstyle, rhist
from itertools import chain
from scipy.stats.kde import gaussian_kde

parser = argparse.ArgumentParser() 
parser.add_argument('pileup_file', type=str, 
                        help='.pileup file generated by samtools')
parser.add_argument('-d', '--dpi', type=int, default=72,
                        help='dpi for saving plot. Default 72. Use 300 for high-quality printouts.')
parser.add_argument('--transparent', action='store_true',
                        help='toggle transparent backglseround (patch) for the plot')
parser.add_argument('--kde', action='store_true',
                        help='use Gaussian kernel density estimator to plot a smooth coverage function')
parser.add_argument('--normed', action='store_true',
                        help='use normed in the call to rhist. See docs to np.hist')
parser.add_argument('-v', '--verbosity', action='count',
                        help='increase output verbosity')
args = parser.parse_args()
matplotlib.rcParams['savefig.dpi'] = args.dpi
  
pos_list = []
hdata = []
with open(args.pileup_file) as f:
    for line in f:
        chro, coord, ref_seq, reads, matches, score = line.split('\t')
        base_position = int(coord)        
        base_coverage = int(reads)
        pos_list.append(base_position)
        hdata += [base_position,] * base_coverage
        
position = np.array(pos_list)

# TODO:  Build the seq space in a separate function
start = min(position)
end = max(position)
pos_space = np.linspace(start, end, end-start)

fig = plt.figure()

if args.transparent:
    fig.patch.set_alpha(0)

ax = fig.add_subplot(111)
defaults = {
    'facecolor': '#dc322f',
    'edgecolor': '#dc322f',
    'alpha': 0.2,
    }
if args.normed:
    defaults.update({'normed': True,})

hist, bis, patches = rhist(ax, np.array(hdata), **defaults)

ax.legend()
ax.set_xlabel('nt')
ax.set_ylabel('Coverage')
ax.title.set_fontsize(18)
if args.kde:
    kde = gaussian_kde(np.array(hdata))
    kde_pdf = kde.evaluate(pos_space)
    # TODO: Implement scaling as a separate funcion
    new_max = max(hist)
    kde_pdf = kde_pdf / max(kde_pdf) * new_max
    plot(pos_space, kde_pdf, color='#268bd2', alpha=0.8)
    ax.fill_between(pos_space, kde_pdf, color="#268bd2", alpha=0.4)
rstyle(ax)
show()